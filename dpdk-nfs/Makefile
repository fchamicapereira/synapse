# Skeleton Makefile for Vigor NFs
# This file dispatches the build process to the other Makefiles
#
# Variables that should be defined by inheriting Makefiles:
# - NF_FILES := <NF files for both runtime and verif-time,
#                automatically includes state and autogenerated files,
#                and shared NF files>
# - NF_LAYER := <network stack layer at which the NF operates, default 2>
# - NF_BENCH_NEEDS_REVERSE_TRAFFIC := <whether the NF needs reverse traffic
#                                      for meaningful benchmarks, default false>
# - NF_PROCESS_NAME := <process name to kill after a benchmark is done>
# Variables that can be passed when running:
# - NF_DPDK_ARGS - will be passed as DPDK part of the arguments
# See Makefile for the rest of the variables

SELF_DIR := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))
NF_DIR := $(shell if [ '$(notdir $(shell pwd))' = 'build' ]; \
            then echo '..';                                  \
            else echo '.'; fi)

# Check that the NF doesn't use clock_gettime directly,
# which would violate Vigor's expectations
# note: 'nf.c' is there for invocations of `make verifast`
# outside of any nf directory, which is perfectly valid.
# otherwise grep with empty argument list will wait on stdin
ifeq (true,$(shell if grep -q clock_gettime                     \
                           $(SELF_DIR)/nf.c                     \
                           $(addprefix $(NF_DIR)/,$(NF_FILES))  \
													 2> /dev/null; 												\
                   then echo 'true';                            \
                   fi))
$(error Please use the vigor_time header instead of clock_gettime)
endif

# Default values for arguments
NF_LAYER ?= 2
NF_BENCH_NEEDS_REVERSE_TRAFFIC ?= false

# Define this for the dpdk and nfos makefiles
# Strip spaces in case NF_DPDK_ARGS is not used
NF_ARGS := $(strip --no-shconf --no-telemetry $(NF_DPDK_ARGS) -- $(NF_ARGS))

# needs to be defined, see shared Makefile
NF_PROCESS_NAME := nf

# Default value for arguments
NF_DEVICES ?= 2

# Output directory
OUT_DIR=build

# DPDK stuff
ifneq ($(shell pkg-config --exists libdpdk && echo 0),0)
    @echo "Error: pkg-config could not find dpdk."
    exit 1
endif

PKGCONF ?= pkg-config
PC_FILE := $(shell $(PKGCONF) --path libdpdk 2>/dev/null)
CFLAGS  += $(shell $(PKGCONF) --cflags libdpdk)
LDFLAGS  = $(shell $(PKGCONF) --static --libs libdpdk)
LDFLAGS += -L$(RTE_SDK)/$(RTE_TARGET)

# Same name for everyone, makes it easier to run them all with the same script
APP := nf
# allow the use of advanced globs in paths
SHELL := /bin/bash -O extglob -O globstar -c
# NF base source;
# somehow because of DPDK makefile magic wildcards mess up everything here,
# so we ask echo to expand those
ifneq (true,$(NF_NO_BASE))
SRCS-y := $(shell echo $(SELF_DIR)/nf*.c)
endif
SRCS-y += $(shell echo $(SELF_DIR)/lib/verified/*.c)
SRCS-y += $(shell find $(SELF_DIR)/lib/unverified -name "*.c" ! -name "*tm*" ! -name "*locks*" -printf "%p ")
SRCS-y += $(NF_FILES)
# Compiler flags
CFLAGS += -I $(SELF_DIR)
CFLAGS += -std=gnu11
CFLAGS += -DCAPACITY_POW2
ifndef DEBUG
CFLAGS += -O3
else
CFLAGS += -O0 -g -rdynamic -DENABLE_LOG -Wfatal-errors
endif

ifdef BATCH
CFLAGS += -DVIGOR_BATCH_SIZE=$(BATCH)
endif

ifndef LCORES
NF_ARGS := --lcores=0 $(NF_ARGS)
else
NF_ARGS := --lcores=$(LCORES) $(NF_ARGS)
endif

# GCC optimizes a checksum check in rte_ip.h into a CMOV, which is a very poor choice
# that causes 99th percentile latency to go through the roof;
# force it to not do that with no-if-conversion
ifeq ($(CC),gcc)
CFLAGS += -fno-if-conversion -fno-if-conversion2
endif

.PHONY: $(OUT_DIR)/$(APP)

all: $(OUT_DIR)/$(APP)

$(OUT_DIR)/$(APP): $(SRCS-y) $(PC_FILE)
	@mkdir -p $(OUT_DIR)
	@$(CC) $(CFLAGS) $(SRCS-y) -o $@ $(LDFLAGS)

clean:
	@$(CLEAN_ALL_COMMAND)

# =========================================
# Verification general commands and targets
# =========================================

# Cleanup
CLEAN_BUILD_ARTIFACTS_COMMAND := rm -rf *.bc *.os *.ll
CLEAN_ALL_COMMAND := $(CLEAN_BUILD_ARTIFACTS_COMMAND) && rm -rf *.bdd *.gv $(OUT_DIR)
# Compilation
COMPILE_COMMAND := clang
# Linking with klee-uclibc, but without some methods we are modeling
# (not sure why they're in klee-uclibc.bca);
# also purge the pointless GNU linker warnings
# so KLEE doesn't warn about module asm
LINK_COMMAND := llvm-ar x $(KLEE_BUILD_PATH)/Release+Debug+Asserts/lib/klee-uclibc.bca && \
                rm -f sleep.os vfprintf.os socket.os fflush_unlocked.os fflush.os && \
                llvm-link -o nf_raw.bc  *.os *.bc && \
                llvm-dis -o nf_raw.ll nf_raw.bc && \
                sed -i -e 's/module asm ".section .gnu.warning.*"//g' \
                       -e 's/module asm "\\09.previous"//g' \
                       -e 's/module asm ""//g' \
                       nf_raw.ll && \
                llvm-as -o nf_raw.bc nf_raw.ll
# Optimization; analyze and remove as much provably dead code as possible
# (exceptions are models;
#  also, mem* functions, not sure why it DCEs them since they are used...
#  and sscanf, which is accessed via its __isoc99_sscanf alias
#  maybe related to LLVM having intrinsics for them?)
# We tried adding '-constprop -ipconstprop -ipsccp -correlated-propagation
#                  -loop-deletion -dce -die -dse -adce -deadargelim -instsimplify';
# this works but the traced prefixes seem messed up :(
OPT_EXCEPTIONS := sscanf,memset,memcpy,memmove,stub_abort,stub_free,stub_hardware_read,stub_hardware_write,stub_prefetch,stub_rdtsc,stub_socket,stub_strerror,stub_delay
OPT_COMMAND := opt -basicaa -basiccg -internalize \
                   -internalize-public-api-list=main,$(OPT_EXCEPTIONS) \
                   -globaldce nf_raw.bc \
                   > nf.bc
# KLEE verification;
# if something takes longer than expected,
# try --max-solver-time=3 --debug-report-symbdex (to avoid symbolic indices)
VERIF_COMMAND := /usr/bin/time -v \
                 klee -no-externals \
                      -allocate-determ \
                      -allocate-determ-start-address=0x00040000000 \
                      -allocate-determ-size=1000 \
                      -dump-call-traces \
                      -dump-call-trace-prefixes \
                      -solver-backend=z3 \
                      -exit-on-error \
                      -max-memory=750000 \
                      -search=dfs \
                      -condone-undeclared-havocs \
                      --debug-report-symbdex \
                      nf.bc

# =======================
# Symbex with DPDK models
# =======================

# Basic flags: only compile, emit debug code, in LLVM format,
#              with checks for overflows (but not unsigned overflows -
#              they're not UB and DPDK depends on them)
#              also no unused-value, DPDK triggers that...
VERIF_FLAGS := -c -g -emit-llvm -fsanitize=signed-integer-overflow -Wno-unused-value
VERIF_FLAGS += -msse4.2 # needed for __builtin_ia32_crc32si
# Basic includes: NF root, KLEE
VERIF_INCLUDES := -I $(SELF_DIR) -I $(KLEE_INCLUDE)
# Basic defines
VERIF_DEFS := -D_GNU_SOURCE -DKLEE_VERIFICATION
# Silly workaround for numaif.h changing between Ubuntu 18.04 and 20.04
ifneq (,$(shell grep -A 1 get_mempolicy /usr/include/numaif.h | grep 'unsigned flags'))
VERIF_DEFS += -DNUMA_GET_MEMPOLICY_UNSIGNED_FLAGS
endif
# Number of devices
VERIF_DEFS += -DSTUB_DEVICES_COUNT=$(NF_DEVICES)
# NF base
VERIF_FILES := $(SELF_DIR)/nf*.c
# Specific NF
VERIF_FILES += $(NF_FILES) *loop.c
# Models
VERIF_FILES += $(SELF_DIR)/lib/models/verified/*.c \
               $(SELF_DIR)/lib/models/unverified/*.c \
               $(SELF_DIR)/lib/models/externals/*.c

# The only thing we don't put in variables is the DPDK model headers,
# since we don't want to use those for the other symbex targets
symbex: clean
	@$(COMPILE_COMMAND) $(VERIF_DEFS) $(VERIF_INCLUDES) \
	                    -I $(SELF_DIR)/lib/models/dpdk \
	                    $(VERIF_FILES) $(VERIF_FLAGS)
	@$(LINK_COMMAND)
	@$(OPT_COMMAND)
	@$(VERIF_COMMAND) $(NF_ARGS)
	@$(CLEAN_BUILD_ARTIFACTS_COMMAND)

# =======
# Running
# =======

run: all
	@sudo ./$(OUT_DIR)/$(APP) $(NF_ARGS) || true

# ====================================
# BDD creation
# ====================================

bdd: symbex
	$(KLEE_BUILD_PATH)/bin/call-paths-to-bdd \
		-out nf.bdd \
		-gv nf.gv \
		klee-last/*.call_path

%.i: %.c
	@mkdir -p $(OUT_DIR)/
	gcc -E $(filter-out -O3 -c,$(CFLAGS)) $^ -o $(OUT_DIR)/$@

pre-processor: all $(NF_FILES:.c=.i)